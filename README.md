# Island problem

Логические задачки с островами.

## Задача 1: Подсчитать количество островов

### Условие

Дан двумерный массив чисел размером ```m x n```, который представляет собой карту, где ```1``` - это земля и ```0``` - это вода. Необходимо вернуть количество островов.

Остров окружен водой и образован путём соединения соседних земель по горизонтали или вертикали. За пределами карты находится вода.

### Объяснение

Чтобы подсчитать количество островов, необходимо пробежаться по карте и при обнаружении острова учесть его один раз. Для этого "утопим" его, т.е. поменяем все его ```1``` на ```0```. Меняем клетку, где мы обнаружили остров, с ```1``` на ```0```. Далее проверяем соседние клетки во всех 4-х направлениях, и если сосед тоже ```1```, то принадлежит обнаруженному острову, и меняем его на ```0```. С соседом соседа поступаем так же. Когда все клетки острова "утоплены", он исчёз с карты и следующая ```1``` будет принадлежать уже другому острову.

![alt text](https://github.com/fediukov/island_problems/blob/main/images/problem_no_1.png "Example")

Для решения понадобится дополнительная функция ```SinkIsland(vector<vector<int>>& grid, int x, int y)```, которая меняет клетку с ```1``` на ```0``` в координатах ```{x,y}``` и рекурсивно вызывает саму себя для соседних ```1```.

### Решение

 ```
    class Island {
    public:
        int CountIslands(std::vector<std::vector<int>> grid) {
            int count = 0;
            for (int y = 0; y < grid.size(); ++y)
            {
                for (int x = 0; x < grid[y].size(); ++x)
                {
                    if (grid[y][x] == 1)
                    {
                        SinkIsland(grid, x, y);
                        ++count;
                    }
                }
            }
            return count;
        }
        
    private:    
        void SinkIsland(std::vector<std::vector<int>>& grid, int x, int y)
        {
            grid[y][x] = 0;
            if (x-1 >= 0 && grid[y][x-1])
            {
                SinkIsland(grid, x - 1, y);
            }
            if (x+1 < grid[0].size() && grid[y][x+1])
            {
                SinkIsland(grid, x + 1, y);
            }
            if (y-1 >= 0 && grid[y-1][x])
            {
                SinkIsland(grid, x, y - 1);
            }
            if (y+1 < grid.size() && grid[y+1][x])
            {
                SinkIsland(grid, x, y + 1);
            }
        }
    };
 ```
